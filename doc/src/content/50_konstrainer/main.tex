\setlength{\parindent}{0pt}
\setlength{\parskip}{0.6em}

%----------------------------------------------------------------------------
\chapter[Constraint language]{Constraint language: Konstrainer DSL}
\label{chap:konst_dsl}
%----------------------------------------------------------------------------

This chapter will introduce my domain-specific language (DSL) created for enforcing Kubernetes constraints. Every keyword and language feature will be discussed with examples. I will explain how to use the language, and if needed, provide explanations on why to use it in a particular way. However, I will not delve deep into the implementation details. The ideas behind the implementation are detailed in Chapter \ref{sec:dsl}~\nameref{sec:dsl}.

\section{Top level}

The main top level keyword is the `server', which declares a new agent. An agent is essentially a web server capable of creating reports and implementing Kubernetes admission webhooks. It is called that, because a web server is generated from it. This keyword takes one argument, its unique name, which must be in kebab-case\footnote{kebab-case: \url{https://developer.mozilla.org/en-US/docs/Glossary/Kebab_case}}, and opens a block. To be precise, it takes two arguments. The second argument is a lambda, but in this context, it is more convenient to refer to the last lambda argument of the `server' keyword as the `block of the server keyword' or the `server block.' I will use this terminology whenever referring to the last lambda argument of a function.

For the code to compile, we also need to import the DSL library, and define a package. The \ref{code:server_boilerplate} code snippet shows the basic template of an agent.

\begin{lstlisting}[caption={Template of a DSL script},language=Kotlin,label=code:server_boilerplate]
package me.btieger

import me.btieger.dsl.*

val serverName = server("server-name") {

}
\end{lstlisting}

Other imports, such as \lstinline|kotlinx.serialization.json.*| or \lstinline|io.fabric8.kubernetes.api.model.*|, might also be necessary. Add them if needed, or use an IDE for Kotlin to automatically add imports.

Inside the server block we get access to three new keywords: `clusterRole', `report', `webhook'.

The `clusterRole' is a \emph{String} property. Using it, we can assign an existing \emph{ClusterRole} to the agent. The \emph{ClusterRoleBinding} will be automatically generated by the Konstrainer-Core when the agent is deployed. If the agent sends any request to the Kubernetes API, it needs authorization to perform those actions. The Konstrainer Helm chart installs a \emph{ClusterRole} that provides read access to all Kubernetes resources. We can reference this \emph{ClusterRole} with the `ReadAny' keyword.

Most properties, such as the `clusterRole' keyword, can only be set once within a block. This ensures clean scripts where properties are not overridden at the end, avoiding confusion for readers.

\begin{lstlisting}[caption={Usage of the clusterRole keyword},language=Kotlin,label=code:clusterrole_usage]
val server1 = server("server1") {
  clusterRole = ReadAny
}
val server2 = server("server2") {
  clusterRole = "my-custom-cluster-role"
}
\end{lstlisting}

Note that, there is a \emph{ClusterRole} in Kubernetes, which gives unlimited access to everything. It is the `cluster-admin' \emph{ClusterRole}. There will be no permission denied errors, if you use it in the script, however I strongly advise against it. I recommend creating a least-privilaged \emph{ClusterRole} for your script.

The main functionality of an agent can be described using the `report' and `webhook' keywords. The `report' keyword opens a new block It can only be used once in each server block. On the other hand, the `webhook' keyword defines an admission webhook that listens to specific events in the cluster. This can be utilized to generate warnings, modify, or reject certain actions.

\subfile{content/50_konstrainer/1_report.tex}

\subfile{content/50_konstrainer/2_webhook.tex}

\section{Summary}

This chapter introduced all the features of the language in detail. With this knowledge I will continue the case study by demonstrating how to write new scripts.

In figures \ref{fig:fltree_1}, \ref{fig:fltree_2} and \ref{fig:fltree_3}, I have included the full tree of the DSL keywords, excluding the `webhookConfigBundle' keyword and some constants. These figures display the scopes of the keywords, where they can be used, their role, type, arguments, and default values.

\subfile{content/50_konstrainer/lang_tree.tex}
