\section{Konstrainer DSL}

The top level keyword is the `server', which declares a new agent. It is called server, because a web server will be generated from it. It takes 1 argument, the name of the server, which must be in kebab-case\footnote{kebab-case: \url{https://developer.mozilla.org/en-US/docs/Glossary/Kebab_case}}, and opens a block. To be precise it takes 2 arguments, the second argument is a lambda, but in this context it is easier to refer to the last lambda argument of the server function as the `block of the server keyword', or the `server block'.

From now on, I will always use this terminology whenever referring to the last lambda argument of a function.

\begin{lstlisting}[caption={Implementation of the server keyword},language=Kotlin,label=code:server_keyword_impl]
@DslMarkerBlock
fun server(uniqueName: String, setup: ServerBuilder.() -> Unit): Server {
    val builder = ServerBuilder().apply(setup)
    return builder.build(uniqueName)
}
\end{lstlisting}

For the code to compile, we also need to import the DSL library, and define a package. The \ref{code:server_boilerplate} code snippet shows the basic template of an agent.

\begin{lstlisting}[caption={Template of a DSL file},language=Kotlin,label=code:server_boilerplate]
package me.btieger

import me.btieger.dsl.*

val serverName = server("server-name") {

}
\end{lstlisting}

Inside the server block we get access to three new keywords: `clusterRole', `report', `webhook'

The `clusterRole' is a String property. With it, we can assign an existing cluster role to the agent. The cluster role binding will be automatically generated by the Konstrainer-Core when the agent is deployed. If the agent sends any request to the Kubernetes API, it needs to have authorization to perform that action. With the Konstrainer helm chart a clusterrole is installed too, which gives reed access to all Kubernetes resources. We can reference this clusterrole with the `ReadAny' keyword.

\begin{lstlisting}[caption={Usage of the clusterRole keyword},language=Kotlin,label=code:clusterrole_usage]
val server1 = server("server1") {
    clusterRole = ReadAny
}
val server2 = server("server2") {
    clusterRole = "my-custom-cluster-role"
}
\end{lstlisting}


The `report' keyword opens a new block. In this block we can create a report from the state of cluster. We can only use the report keyword once in each server block.

The `webhook' keyword defines a webhook which listens to certain events in the cluster. This can be used to create warnings, modify or reject some actions.

\subsection{Report block}

The report block allows us to relatively easily create an overview of the state of the cluster. First let's see how could any report be created regardless of this DSL. To create any sort of report, the necessary data must be fetched, and it must be processed and aggregated. To support these use-cases, I created dedicated language features but also relied on existing libraries and the built-in features of Kotlin.

In my model of creating a report, first you should fetch the data from the k8s API, like the list of pods and deployments. Optionally after that, you can make some processing (e.g.: filtering out namespaces you don't care about, or extracting pod labels for easier associations between resources). Finally, you create aggregation groups where you can tag certain k8s resources based on custom logic. Creating an aggregation group is basically iterating over a kind of resources, (like the deployments or pods) and applying one or more `if' statements to them. If an `if' statement evaluates to true, a tag is attached to that resource in the result report. The following pseudo-Java code snippet shows an example how this model works:

\begin{lstlisting}[caption={Example report in pseudo-Java},language=Java,label=code:pseudo_report]
KubernetesClient k8s = /* Instantiate a client */;
// Create map to associate our resources with their custom tags
Map<ServicePodPairs, List<String>> aggregationGroup = new HashMap<>();
// Fetching data
List<Service> services = k8s.services().list().getItems();
List<Pod> pods = k8s.pods().list().getItems();

// Associate services with their pods
List<ServicePodPairs> podsWithServices = /* Custom logic */

for (ServicePodPairs pair : podsWithServices) {
    // Create an empty list for the pair, to store its tags.
    aggregationGroup.set(pair, new ArrayList<String>);
    if (pair.getPods().size().equals(0)) {
        aggregationGroup.get(pair).add("Service has no pods");
    }
    if (pair.getService() == null) {
        aggregationGroup.get(pair).add("No service for the pods");
    }
}
\end{lstlisting}

A small note on why I designed the model this way: API calls are orders of magnitude slower than operations made on the CPU. My model minimizes the number of API calls thus making the process faster. The other approach would be to fetch only the services first, and during the loop fetch the pods for only that service. This would be slightly more memory efficient, but significantly slower. I approximated the memory footprint of a pod to be around 5 KB. A thousand pods would take approximately 5 MB, which is insignificant but fetching them only once can save us a thousand API calls.

\subsubsection{Fetching data from k8s}

For fetching data, I created two language features: the imperative `kubectl' and declarative `kubelist' commands. Both commands open a new block, in which we can access the k8s API. Inside the block of these commands, everything is executed on an instance of a KubernetesClient class from the fabric8\footnote{fabric8: https://github.com/fabric8io/kubernetes-client} library. This is an open source third party Kubernetes client for Java. With the Kotlin terminology we say that the receiver of your lambda function is the KubernetesClient class.

Both commands are exception safe, meaning if an error occurs inside their block, or during the k8s API call, they return a default value and include the error in the report instead of causing the entire report to fail. The default return value for `kubelist` is an empty list, for the `kubectl` it is null. They are also null safe. `kubelist' always returns a list of non-null values, and list itself is never null. Even dough, `kubectl' can return a null value, it is marked nullable, so the built-in null safety of Kotlin ensures, that it is used only safely.

The following example shows, how to get the list of pods from all user created namespaces:

\begin{lstlisting}[caption={Usage of kubelist and kubectl},language=Kotlin,label=code:kubelist_usage]
val pods: List<Pod> = kubelist(omittedNss = nonUserNss) { pods() }
val pods: List<Pod>? = kubectl { pods().inAnyNamespace().list().items }?.filter { it.metadata.namespace !in nonUserNss }
\end{lstlisting}

The `kubelist' is more convenient, streamline, and I recommend using only that. On the other hand `kubectl' gives full control which might be necessary in some edge-cases.

With `kubectl' the return value of the command will be the return value within its scope, or null if an error occurs. You have full control, but you have to do everything by hand. The best uses-case for `kubectl' is when you only want to fetch a single resource and not the list of resources, since `kubelist' can only fetch a list of resources. The \ref{code:get_logs} code snippet shows how to get the logs of all pods, which can only be done using the `kubectl' command.

\begin{lstlisting}[caption={Download pod logs},language=Kotlin,label=code:get_logs]
val pods = kubelist { pods() }
val logs: Map<Pod, String?> = pods.associateWith {
    kubectl {
        pods()
            .inNamespace(it.metadata.namespace)
            .withName(it.metadata.name)
            .log
    }
}
\end{lstlisting}

A small note on the `kubectl' command: Since it gives full control to the k8s API, we can send requests other than GET. For example, we can write down that we want to delete a deployment within our report, but the command will fail, because of authorization issues. It would also be a bad idea to execute commands which modify the cluster, because a report is run whenever the `/aggregator' endpoint is called of the agent, and we definitely don't want to modify the cluster whenever someone refreshes the report page in their browser.

With `kubelist' many things are added automatically. In the \ref{code:kubelist_usage} code snippet you can see that the `.inAnyNamespace().list().items' part is omitted, because it is added automatically. Let's break down what this part actually does. When executing k8s API calls, you need to specify the namespace you are working in. Without it, the default value would be the namespace of the agent. That is what the `inAnyNamespace()' part does. The `list()' function sends the GET request to the k8s API. The `items' property is derived by the Kotlin language from the `getItems()' Java function. The `list()' function returns a ResourceList object, and the `getItems()' returns the resources as a `List<Resource>' object.

The filtering of the user namespaces are also done differently. With the `kubectl' command filtering is done in a more imperative way, defining how to exactly ignore those namespaces. On the other hand, with `kubelist' we only have to set a parameter.

Let's go through the namespace selection options of the `kubelist' command.

\begin{lstlisting}[caption={Usages of kubelist},language=Kotlin,label=code:kubelist]
val pods = kubelist { pods() }
val pods = kubelist(omittedNss = listOf("kube-system")) { pods() }
val pods = kubelist(namespace = "my-namespace") { pods() }
\end{lstlisting}

The \ref{code:kubelist} code snippet shows all the possible ways to use this command. With the first method, it lists the pods from all namespaces except the system namespaces.

The second method show how to override the list of ignored namespaces. There are 3 built in lists: none, nonUserNss, systemNss. The \ref{code:kubelist_lists_impls} shows how these lists are implemented, and which namespaces they include. Using `kubelist(omittedNss = systemNss) { pods() }' is the same as `kubelist { pods() }'.

\begin{lstlisting}[caption={Usages of kubelist},language=Kotlin,label=code:kubelist_lists_impls]
val systemNss = listOf("kube-system", "kube-node-lease", "kube-public")
val nonUserNss = listOf("kube-system", "kube-node-lease", "kube-public", "default")
val none: List<String> = listOf()
\end{lstlisting}

With the last method, you can select a single namespace to work within.

\subsubsection{Transforming data}

Sometimes you may want to process the data between fetching it and using to create an aggregation. The use-cases can be filtering on some criteria, or associating different types of resources, like pods with services. For example if you want to associate pods with other resources, I found that it is worth extracting the pods labels to a set. It makes it easier to write the aggregations later. The \ref{code:pod_labels} code snippet shows how to extract the pod labels, and use them to find if a service has any pods.

\begin{lstlisting}[caption={Extraction of pod labels},language=Kotlin,label=code:pod_labels]
val pods = kubelist { pods() }
val podLabels = pods.map { it.metadata.labels }.toHashSet()
val service = // Get a single service resource
val serviceHasPods = podLabels.any { podLabel ->
    service.spec.selector.all { podLabel.entries.contains(it) }
}
\end{lstlisting}

It is complicated I admit, but this is complicated on the mathematical level. With mathematical precision, expressing the formula which determines if a service has pods or not is complicated. It requires first-order logic, which can get complicated in the context of the already complicated Kubernetes infrastructure.

For data manipulation and resource associations I did not add anything new, rather I relied on the extension methods of collections from the Kotlin standard library\footnote{https://kotlinlang.org/docs/collection-transformations.html}. These functions are excellent for data processing, and I used them extensively during the creation of the case study.

\subsubsection{Aggregation groups}


\subfile{lang_tree.tex}
